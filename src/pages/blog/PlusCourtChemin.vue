<script setup lang="ts">
import ToC from "@/components/blog/ToC.vue";
import Title from "@/components/blog/Title.vue";
import Paragraph from "@/components/blog/Paragraph.vue";
import Maze from "@/components/shortest-path/Maze.vue";
import InlineCode from "@/components/blog/InlineCode.vue";
import Highlight from "@/components/Highlight.vue";
import Image from "@/components/blog/Image.vue";
import Code from "@/components/blog/Code.vue";
import Block from "@/components/blog/Block.vue";
const component = "ShortestPath";

</script>

<template>
  <div>
    <ToC></ToC>
    <Title>Plus court chemin</Title>
    <Paragraph>
      <template #title>
        ğŸ‘‹ Introduction
      </template>
      <template #subtitle>
        ğŸ¤” C'est quoi ?
      </template>
      <template #content>
        Les <Highlight color="yellow">algorithmes de plus court chemin</Highlight> sont essentiels en informatique et en mathÃ©matiques pour rÃ©soudre des problÃ¨mes dâ€™optimisation dans des graphes.
        Ils ont des applications variÃ©es, allant des rÃ©seaux de tÃ©lÃ©communication Ã  la planification de trajets, en passant par les jeux vidÃ©o.
        Cette article se concentre sur deux algorithmes populaires : <InlineCode>Dijkstra</InlineCode> et <InlineCode>A*</InlineCode>.
      </template>
    </Paragraph>
    <Paragraph>
      <template #subtitle>
        ğŸ§‘â€ğŸ« Avant de se lancer dans les algos...
      </template>
      <template #content>
        Pour comprendre les algorithmes de plus court chemin, il est important de connaÃ®tre les bases des graphes.
        Un <Highlight color="yellow">graphe</Highlight> est un ensemble de <Highlight color="purple">sommets</Highlight> reliÃ©s par des <Highlight color="red">arÃªtes</Highlight>.
        <br>
        Les graphes peuvent Ãªtre <Highlight color="green">orientÃ©s</Highlight> (les arÃªtes ont une direction) ou <Highlight color="blue">non orientÃ©s</Highlight> (les arÃªtes n'ont pas de direction).
        Les graphes peuvent Ã©galement Ãªtre <Highlight color="orange">pondÃ©rÃ©s</Highlight> (les arÃªtes ont un poids).

        <Image legend="Exemple de graphe orientÃ©, non pondÃ©rÃ©">
          <img src="@/assets/shortest-path/graph.png" alt="graph" class="w-72 h-fit" />
        </Image>

        <Block title="English mode" type="info">
          En anglais, un graphe est appelÃ© <InlineCode>graph</InlineCode>, un sommet est appelÃ© <InlineCode>vertex</InlineCode> et une arÃªte est appelÃ©e <InlineCode>edge</InlineCode>.
        </Block>
      </template>
    </Paragraph>
    <Paragraph>
      <template #title>
        ğŸ§‘â€ğŸ’» Algorithmes
      </template>
      <template #subtitle>
        Dijkstra
      </template>
      <template #content>
        Lâ€™algorithme de Dijkstra trouve le plus court chemin Ã  partir dâ€™un nÅ“ud source vers tous les autres nÅ“uds dans un graphe pondÃ©rÃ© avec des poids positifs.
        <br>
        <Code :parent="component" file="DijkstraPseudoCode"></Code>
        <Block title="Attention" type="warning">
          L'idÃ©e de Dijkstra est d'explorer tous les chemins possibles. On va Ãªtre sÃ»r de trouver le chemin le plus court, mais son temps de calcul peut Ãªtre consÃ©quent en fonction de la taille du graphe.
        </Block>
      </template>
    </Paragraph>
    <Paragraph>
      <template #subtitle>
        A*
      </template>
      <template #content>
        L'algorithme <Highlight color="yellow">A*</Highlight> (prononcÃ© "A star") est une amÃ©lioration de l'algorithme de Dijkstra, en ce sens qu'il utilise une heuristique pour guider sa recherche vers l'objectif.
        <Code :parent="component" file="AStarPseudoCode" ></Code>
        Source : <a href="https://fr.wikipedia.org/wiki/Algorithme_A*">A* (Wikipedia)</a>
        <Block title="Note" type="info">
          A* utilise une fonction de coÃ»t <InlineCode>f(n) = g(n) + h(n)</InlineCode>, oÃ¹ <InlineCode>g(n)</InlineCode> reprÃ©sente le coÃ»t pour atteindre le nÅ“ud <InlineCode>n</InlineCode> depuis le nÅ“ud de dÃ©part, et <InlineCode>h(n)</InlineCode> est une estimation du coÃ»t restant pour atteindre l'objectif depuis <InlineCode>n</InlineCode>.
        </Block>
        L'efficacitÃ© de A* dÃ©pend de la qualitÃ© de l'heuristique utilisÃ©e. Une heuristique admissible (qui ne surestime jamais le coÃ»t rÃ©el pour atteindre l'objectif) garantit que A* trouvera le chemin le plus court de maniÃ¨re optimale.
      </template>
    </Paragraph>

    <Paragraph>
      <template #title>
        ğŸ” Comparaison
      </template>
      <template #content>
        Il est important de comparer les performances de Dijkstra et A* dans diffÃ©rentes situations pour comprendre leurs avantages et inconvÃ©nients respectifs.
        <Block title="ComplexitÃ©" type="warning">
          La complexitÃ© temporelle de Dijkstra est <InlineCode>O((V+E) \log V)</InlineCode>, oÃ¹ <InlineCode>V</InlineCode> est le nombre de sommets et <InlineCode>E</InlineCode> est le nombre d'arÃªtes.
          Pour A*, la complexitÃ© temporelle dÃ©pend de la qualitÃ© de l'heuristique, mais dans le pire des cas, elle peut Ã©galement Ãªtre similaire Ã  celle de Dijkstra.
        </Block>
        Vous pouvez tester les deux algorithmes sur le labyrinthe ci-dessous.
        <Block title="Comment utiliser ? " type="info">
          Vous pouvez changer les murs en cliquant sur les cases du labyrinthe. Le point de dÃ©part est la case <Highlight color="green">ğŸŸ© verte</Highlight> et l'objectif est la case <Highlight color="red">ğŸŸ¥ rouge</Highlight>. Vous pouvez Ã©galement changer le dÃ©part et l'objectif en cliquant sur les cases correspondantes.
        </Block>
        <Maze class="mt-2" />
      </template>
    </Paragraph>

    <Paragraph>
      <template #title>
        ğŸ Conclusion
      </template>
      <template #content>
        <Highlight color="yellow">Dijkstra</Highlight> offre une solution robuste et garantie pour trouver le plus court chemin, mais peut Ãªtre lent pour des graphes trÃ¨s grands.
        <Highlight color="yellow">A*</Highlight> apporte une dimension supplÃ©mentaire avec son heuristique, permettant des recherches plus rapides dans de nombreux cas, mais sa performance dÃ©pend fortement de la qualitÃ© de l'heuristique.
      </template>
    </Paragraph>
  </div>
</template>

<style scoped>

</style>